1:跨域请求资源的方法
	proxy代理:proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。
	CORS:一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：
		res.writeHead(200, {
   			"Content-Type": "text/html; charset=UTF-8",
   			"Access-Control-Allow-Origin":'http://localhost',
    		'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    		'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'
		});
	JSONP:通过动态创建script来读取他域的动态资源，获取的数据一般为json格式.
		JSONP的缺点:无法实现POST请求,难判断是否请求成功,一般使用超时时间判断
	
2:垃圾回收机制及内存管理
	标记清除:变量进入环境,加标记. 变量离开环境,去除标记.无标记的,清除
	引用计数:即通常说的GC机制
	
3:开发过程中遇到的内存泄漏问题,如何解决?
	什么是内存泄漏? 一块内存即不能用,也不能回收
	内存泄漏的几种情况
		1:当页面中元素被移除或替换时,元素绑定的时间仍然没有被移除
		2:闭包

4:JavaScript中继承实现
	原型链和借用构造函数

5:jQuery库中$是什么?
	$() 函数是 jQuery() 函数的别称。$() 函数用于将任何对象包裹成 jQuery 对象，
	接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，
	它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。
	
6:$(this) 和 this 关键字在 jQuery 中有何不同？
	$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。
	this是当前执行的上下文

7:jQuery中的Delegate()函数有什么作用？
	如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：
		$("ul").delegate("li", "click", function(){ $(this).hide(); });
	当元素在当前页面中不可用时，可以使用delegate()
	
8:$(document).ready()方法和window.onload有什么区别？
	window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。
	$(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。
	
9:get和post方法有什么不同? ?
	请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。
	参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。
	数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多
	安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。
	
10:简述一下src与href的区别
	href是指向网络资源所在位置,建立和当前元素和当前文档之间的链接,类似锚点
	src是指向外部资源的位置,指定的内容将会嵌入到文档中当前标签所在的位置;在请求src资源时会将其指向的资源下载,
	并应用到文档中,例如js脚本,img图片和frame等元素
	当浏览器解析到该元素时,会暂停其他资源的下载和处理,直到将该资源下载,编译,执行完毕,图片和框架等元素也是如此
	
11:简述同步和异步的区别
	同步是阻塞模式,异步是非阻塞模式
	同步就是指一个进程在执行某个请求的时候,若该请求需要一段时间才能返回信息,那么这个进程将会一直等待下去,直到消息返回
	异步是指进程不需要一直等待下去,而是继续执行下面的操作. 当有消息返回时,再回来继续执行该进程
	
12:px和em的区别
	px是固定的,表示像素值
	em是不固定的,浏览器默认的都是16px,且em会继承父级元素的字体大小
	
13:浏览器的内核分别是什么
	IE:trident内核
	Firfox:gecko内核
	Safari:webkit内核
	Opera:以前是presto,现在是blink
	chrome:Blink
	
14:优雅降级和渐进增强
	渐进增强:针对低版本浏览器进行构建页面,保证最基本的功能,然后再针对高版本浏览器增加效果
	优雅降级:一开始就构建完整的功能,然后再针对低版本浏览器进行兼容
	
15:sessionStorage,localStorage和cookie之间的区别
	1:需要发送到:cookie数据需要发送到服务器,会造成一定的带宽浪费,web Storage保存在本地
	2:数据存储大小不同:cookie 4K, webStorage 5M
	3:有效期限不同:cookie在设置的过期时间之前一直有用,session在当前会话关闭前有用,localStorage一直有用除非用户删除
	4:作用域不同:cookie和localstorage在同源同窗口中都是共享的,session只在当前页面有效

16:Web Stroage与cookie不同
	1:webstorage存储空间更大,ID8下每个独立的存储空间为10M,其他浏览器也都不同
	2:存储内容不会发送到服务器,
	3:接口更多,cookie需要自己封装接口
	3:独立的存储空间,每个域(包括子域)有独立的存储空间,各个存储空间是完全独立的,因此不会造成数据混乱
	
17:Ajax的优缺点及工作原理
	定义:Ajax:异步js和XML,是一种快速创建动态网页的技术,是一种无需重新加载整个网页的情况下,能够更新部分网页的技术
	优点:1:减轻了服务器的负担,按需取数据
		2:局部刷新页面,用户体验更好
		3:基于XML,被广泛支持
	缺点:1:局部刷新,页面的后退按钮是没用的
		2:对流媒体和移动设备的支持不是很好
		3:大量使用JavaScript和ajax引擎,在编写的时候需要考虑浏览器兼容性
	工作原理:
		1:创建ajax对象
		2:判断数据传输方式
		3:打开链接 open()
		4:发送 send()
		5:判断服务器返回状态码,并执行回调
		
18:规避JavaScript多人开发函数重名问题
	1:命名空间
	2:封闭空间
	3:js模块化MVC
	4:变量装换成对象的属性
	5:对象化

19:减轻页面加载时间的方法
	1:压缩css,js文件
	2:合并css,js文件,减少http请求
	3:css文件放在页面顶,js文件放在页面底
	4:减少dom操作,尽可能用变量替代不必要的dom操作
	5:使用CDN,图片预加载,AJAX缓存, 服务器常用文件缓存,
	6:文件压缩,
	7:使用CSS sprite
	
20:你了解到的Web攻击技术
	1:XSS(跨站脚本攻击) 是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML或JS进行的攻击,
	2:SQL注入
	3:CSRF(跨站点请求伪造) 指攻击者通过设置好的陷阱,强制对已完成的认证用户进行非预期的个人信息或设定信息等某些状态更新

21:Web前端开发,如何提高页面性能优化
	内容:
		1:减少HTTP请求
		2:减少DOM节点操作
		3:使用ajax缓存
	css:
		1:把css放到代码页上方
		2:从页面中剥离JavaScript和css
		3:精简JavaScript和css
		4:减少使用css表达式
	JavaScript:
		1:将JavaScript放到代码页下方
		2:移除重复脚本
		3:精简JavaScript和css
		4:从页面中剥离JavaScript和css
	面向图片:
		1:优化图片
		2:使用恰当的图片格式
		3:不要在HTML中使用缩放图片
		4:使用CSS sprites(css 精灵)技巧对图片进行优化

22:前端开发中如何优化图像
	1:不用图像,尽量用CSS3效果代替,比如实现阴影,圆角,等效果
	2:使用矢量图SVG代替位图
	3:使用恰当的图片格式.我们常见的图片格式有JPEG,GIF,Png
	4:按照HTTP协议设置合理的缓存
	5:使用字体图标 webfont,css sprite等
	6:用css或JavaScript实现预加载
	7:用JavaScript实现懒加载
	8:使用WebP图片格式
	
23:图片格式和区别
	矢量图: webfont,SVG
	位图:gif,jpg,png
		gif:gif是一种无损,8位图片格式
		jpg:jpg 微损,允许轻微色彩失真, 适合色彩丰富的图片
		png:
	
24:浏览器是如何渲染页面的
	1:解析HTML文件,创建DOM树
		自上而下,遇到任何样式与脚本都会阻塞
	2:解析CSS,优先级:浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式；
	3:将CSS与DOM合并,构建渲染树
	4:布局和绘制,重绘和重排

25:如何避免XSS?
	禁止危险脚本
	
26:谈谈你对模块化的理解
	什么是模块化:
		1:模块化是为了减少系统耦合度,提高高内聚,减少资源循环依赖,增强系统框架设计
		2:模块化为了便于维护,提高代码复用性
		3:模块化开发,针对功能和特性组织代码,JS方面而言,模块化解决了独立作用域,API暴露,按需加载,安全合并,
		  依赖管理等问题  css反面主要是解决依赖管理,组件内部样式管理等问题
	
27:如何使用缓存
	可以基于http的头信息控制缓存
	ajax请求对于早期的IE浏览器默认就是缓存的,可以通过时间戳防止缓存
	
28:谈谈你对预加载的理解
	Web预加载指的是在网页全部加载完成之前,在页面优化显示一些主要内容,以提高用户体验,对于一个较庞大的网站,
		如果没有使用预加载技术,用户界面就会显示教长时间的空白,可以使用JavaScript预先加载一些内容
	例如，可以通过js预先从服务加载图片资源(动态创建Image，设置src属性)，只要浏览器把图片下载到本地，
		就会被缓存，再次请求相当的src时就会优先寻找浏览器缓存，提高访问速度。
	
29:缓存和预加载的区别是什么?
	缓存是指把请求过的数据缓存起来,下次再次请求的时候直接使用就行
	预加载是指提前把需要的内容加载完成,当需要的时候,因为已经提前加载好了,所有不存在延迟
	
30:图片如何压缩
	可以使用一些在线的图片压缩工具,
	优先使用png,而不是jpg,
	尝试使用png8
	使用css sprite
	
31:压缩文件有哪些方法?
	Grunt,sass,ant压缩
	
32:如何区分静态页面和动态页面?
	看后缀,一般动态页面后缀都有'?'和'&'号,
	
33:字符串拼接和模板引擎,项目中会如何操作?模板引擎会不会利于SEO优化?
	简单的数据渲染,字符串拼接就可以,复杂一点的使用模板引擎,需要关注SEO优化的页面最好使用后台渲染
	
34:前台兼容性问题有哪些?
	主要是前端API渲染差异
	
35:你如何对网站的文件和资源进行优化,期待的方案有哪些?
	文件合并,文件压缩
	文件缓存
	使用CDN
	
36:懒加载是用滚轮判断高度好还是用插件?
	使用插件比较好,插件考虑的问题比较全面,仅通过滚轮判断很容易导致一些副作用(比如一次请求多次)

37:如何缓存整个页面?在没有网络的时候可以来回跳转
	使用H5,设置H5里面的cache manifest
	
38:CDN是什么
	CDN全称:内容分发网络,
	CND加速原理:将网站内容缓存在网络网格边缘(离用户接入网络最近的地方)
	CDN的特点:
		1:本地加速
		2:镜像服务
		3:远程加速
		4:带宽优化
		5:集群抗攻击
		
39:浏览器一次可以从同一个域名下请求多少资源?
	浏览器的并发请求数目是针对同一域名的,不同浏览器对这个限制数目都不一样,不过一般是在10以内
	
40:image和canvas在处理图片时有什么不同?
	image是通过对象的形式描述图片的,
	canvas是通过将图片绘制在画布上
	
41:简述移动开发的注意点,如何做好不同手机的适配,你以前的项目是怎么做的?
	单独做移动端项目,采用百分比布局
	采用响应式的方式做适配
	
42:简述移动开发的注意点,如何做好不同手机的适配?
	单独做移动端项目,使用百分比布局,
	使用响应式的方式做适配
	
43:HTTP协议和TCP协议有什么区别?
	TCP/IP是传输层协议,主要解决数据如何在网络层传输,
	HTTP是应用层协议,HTTP是使用TCP协议实现的

44:设计模式有哪些?列举你在前端开发中自己应用或者了解到其他框架所用到的设计模式
	简单工厂,虚拟工厂,单例,适配器,解释器,桥接,享元,组合,装饰,参与者,等待者,观察者,状态,策略,MVC,MVVM,链模式,代理模式
	前端开发中自己最常用的有,观察者模式,链模式,委托模式
	
45:JavaScript中的事件级别
	DOM事件级别:
		DOM0:document.click(funciton(){});
		DOM2:document.addEventListener('click',function(){})
	DOM事件模型:冒泡和捕获
	DOM事件流: 捕获阶段,目标阶段,冒泡阶段	
	事件捕获具体流程: window>document>body>...>具体元素
	
46:前端如何进行错误监控?
	前端错误分类:运行时错误和资源加载错误
	运行时错误: try...catch 或 window.onerror
	资源加载错误: object.onerror 
	
47:MVVM模式与MVC模式的区别
	MVVM: model-view-view-model 模型
		低耦合:视图可以独立于model变化而修改
		可重用性:把一些视图逻辑放在一个viewModel中,让很多view重用这段逻辑
		独立开发:开发专注逻辑,设计专注界面
		可测试:MVVM模式开发中只需要测试单个View
	MVC:model-view-control
		MVC和MVVM其实差别不大,都是同一种设计模式,只不过在MVVM中将MVC中的Control换成了Model
		这样做的优点是,减少了MVC中的大量DOM节点操作
	
48:标准盒模型和IE盒模型有什么区别?
	都是margin(外边距),border(边框),padding(内填充),content(正文内容)组成
	其中标准盒模型: width = content
	IE盒模型: width = content + padding + border
	
49:浏览器是怎样解析CSS选择器的
	CSS选择器的解析是从右向左解析的
	
50:在网页中使用的字体大小应该是偶数还是奇数
	偶数:偶数字号更容易和其他web设计构成百分比关系,Window自带的宋体点阵也只提供12,14,16px三个大小的点阵

51:元素竖向的百分比设定是相对于容器的高度吗?
	当按百分比设定一个元素的宽度时,它是相对于父容器的宽度计算的
	但是对于一些表示竖向距离的属性,当按百分比设定的时候,依据的也是其父容器的宽度,而不是高度
	
52:什么是响应式设计?响应式设计的基本原理是什么?如何兼容低版本的IE
	响应式网站设计是一个网站能够兼容多个终端,而不是为每一个终端做一个特定的版本
	基本原理是:通过媒体查询检测不同的设备屏幕尺寸做处理
		<meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1 user-scalable=no"/>
		
53:如何解决Chrome浏览器下不支持CSS字体小于12px的问题?
	通过transform缩放
	
54:rgba()和opacity的透明效果的异同
	opacity作用于元素以及元素内的所有内容的透明度
	rgba()只作用于元素的颜色和背景色
	
55:手动写动画需要设置的最小时间间隔和原因
	多数显示器的默认频率是60HZ,所以手动写动画设置的最小时间间隔是 1000/60 = 16.7ms
	
56:dispaly:inline-block 什么时候会显示间隙?
	有空格时候会显示间隙: 移除空格
	margin正值的时候:margin使用负值
	使用font-size的时候:font-size:0
	
57:overflow属性的参数及其含义
	overflow属性定义溢出元素内容区域如何处理
		scroll:出现滚动条
		auto:子元素内容大于父元素时出现滚动条
		visible:溢出的元素内容出现在父元素之外
		hidden:溢出的元素内容隐藏
		
58:请简述一下HTTP2协议的特性
	多路复用请求
	对请求划分优先级
	压缩HTTP头
	服务器推送流
	
59:如果不给cookie设置过期时间会怎样?
	在浏览器会话结束时过期
	
60:执行以下程序段后,X的值是?
	var x=0;
	switch(++x)	//x=1
	{
		case 0: ++x;
		case 1: ++x;	//x=2
		case 2: ++x; 	//x=3
	}
	
61:我们需要实现动态加载一个JavaScript资源,但是有几处不知道如何处理,需要在您的帮助完成这项工作
	var script = document.createElement('script');
	var head = documnet.getElementsByTagName('head')[0];
	script.type = 'text/javascript'
	script.src = "//i.alicdn.com/resource.js"
	//绑定资源或成功事件
	script.onreadystatechange = function(){
		//判断资源加载状态是否为加载成功或加载完成
		if(/^(loaded|complete)$/.test(script.readyState)){
			script.onreadystatechange = null;
				...
		}
	};
	//绑定资源加载失败事件
	script.onerr = function(){
		...
	}
	
62:在浏览器控制台执行以下结果,输出的信息是
	function test(){
		var n = 4399;
		function add(){
			n++;
			console.log(n);
		}
		return {n:n,add:add}
	}
	var result = test();
	var result2 = test();

	result.add();			//n=4400
	result.add();			//n=4401
	console.log(result.n)	//n=4399
	result2.add()			//n=4400
	
63:关于3D变换属性
	在blink或webkit浏览器中,某个元素具有3D或透视变换的属性,会让浏览器创建单独的图层
	在我们平时会使用left和top修改元素位置,但这样会触发重布局,取而代之的是使用translate,这个不会触发重布局
	解决浏览器渲染的首要问题是避免图层的重绘和重布局
	
64:移动端要想动画性能流畅,应该使用3D硬件加速,因此最好给页面中的元素添加translate3D() 或translateZ(0)属性,来触发硬件加速?
	可通过这种方法来优化CSS3的动画效果,在一个没有特效的普通页面中,一个页面中只有一个图层,当图层中的元素大小位置发生变化
	时,整个页面都要重布局,可能会出现卡顿.使用3D,透视变换的属性,能强迫浏览器单独绘制一个图层,由GPU来重绘动画,能减少卡顿
	的情况,然而使用GPU可能会导致严重的性能问题,因为它增加了内存的使用,而且他会减少移动端电池的寿命,因此使用的时候要小心
	
65:margin重叠部分如何消除: overflow:hidden

66:常见的行内元素,块级元素有哪些?
	行内元素:a b br i span input select 
	块级元素:div p h1 h2 h3 h4 form ul
	
67:给一个元素设置bakcground,其中padding和margin部分会生效吗?  答:不会

68:简述一下浮动,如何清除浮动?
	浮动最开始出现是为了让文字环绕图片
	浮动的元素没有高度,不用占位置的
	清除浮动: 1,在父元素的最后加一个冗余元素并为其设置clear:both
			2,给父元素添加overflow:hidden||auto
			
69:简述一下position
	position:元素定位方式 static|absolute|relative|fixed
		static:无特殊意义,使用浏览器默认的定位
		absolute:绝对定位,相对于上一个使用了absolute定位的元素进行定位
		relative:偏移定位,相对于元素原来的位置进行定位
		fixed:相对屏幕定位
	
70:如何使用原生JS给CSS设置class,
	var element = document.getElementById('elementname');
	element.classList.addClass('className');
	element.classList.removeClass('className');
	
71:import和link的区别,如果import一个非常重要而且非常大的重要文件,会发生什么?
	从属关系区别:@import是CSS提供的语法规则,只有导入样式表的作用;
			  link是HTML提供的标签,不仅可以加载CSS文件,而且可以加载其他文件
	加载顺序区别:加载页面时,link标签引入的css被同时加载,@import引入的CSS将在页面加载完毕后被加载
	兼容性区别:@import是css2.1 后加入的语法,再早期IE版本中不能使用
	DOM可控性区别: @import是CSS语法,不可用js控制,link是HTML语法,可使用js操作DOM,插入link标签来改变样式
	权重区别:link引入的样式权重大于@import引入的样式
	如果引入一个非常大的CSS文件,会导致闪屏
	
72:简述选择器和其优先级,为什么不推荐使用!important
	ID>class,伪类>标签
	当!important被用在一个样式声明中,该样式声明会覆盖任何其他的声明
	
73:JS的数据类型,以及对应的内存类型
	基本数据类型是栈存储,存的是数值
	引用数据类型是堆存储,存的是引用
	
74:伪数组类型与真正的数组类型的区别，伪数组类型不能使用pop（）和push（），
    那如何将一个伪数组类型转换为一个真正的数组类型
    Array.prototype.slice.call(fakeArray)

75:getXXXByXXX 和querySelector的区别
	前者获取的是动态集合,选出的元素会随文档改变,
	后者获取的是静态集合,选出的元素不会随文档改变
	前者获取的是伪数组,后者获取的是真数组
	
76:rem与em的使用和区别详解
	rem基于HTML元素的字体大小来决定,em根据使用它的元素的大小来决定
	
77:HTTP状态码
	常见:200 服务器成功返回网页  404:请求的网页不存在  503:服务不可用
	1XX:临时响应
	2XX:成功
	3XX:重定向
	4XX:请求错误
	5XX:服务器错误
	
78:TCP3次握手和4次挥手
	3次握手:发送端首先发送一个带有SYN标志的数据包发给对方,对方收到后发送一个带有SYN/ACK回来,
		  发送端收到后再次回传一个ACK表示"握手"结束
	4次挥手:主动关闭方发送一个FIN,告诉被动关闭方已经不会向它发送消息了
		  被动关闭方收到FIN后,发送一个ACK给对方,确认序号为收到序号+1
		  被动关闭方发送一个FIN,告诉主动关闭方不会向它发送消息了
		  主动关闭方收到FIN后,发送一个ACK给被动关闭方,确认序号为受到序号+1
		  
79:XSS原理及防范(跨站脚本攻击)
	原理:攻击者往web页面插入恶意代码,骗取用户点击后窃取cookie中的用户隐私消息
	防范:1:对用户输入进行处理 2:对用户cookie进行处理,不要在cookie中放直接泄漏用户信息的数据
		3:使用cookie和ip绑定
		
80:CSRF原理及防范(跨站点请求伪造)
	原理:在用户不知情的情况下执行其他站点的请求
	攻击过程:1:用户以合法身份登录网站A,
		   2:用户登录危险网站B
		   3:危险网站B请求打开A,
		   4:用户同意,危险网站提交表单给网站A
	防范:1:验证HTTP头部refer信息
		2:在请求地址中添加token并验证
		3:在HTTP头中自定义属性并验证
		
81:web worker和websocket
	webworker:H5中新增的多线程实现
	websocket:H5中新增的信息,服务器可以主动发起通信,用来代替以前的轮训
	
82:HTTP和HTTPS
	HTTP:基于TCP的应用层协议 HTTPS在HTTP层和TCP层新增SSL层
	HTTP:80端口 HTTPS:443端口
	
83:性能优化
	代码层面:避免使用CSS表达式,避免使用高级选择器,通配选择器   CSS放头部,js放尾部,css和js精简化
	缓存利用:AJAX缓存,使用CDN,减少DNS查询使用外部JS和CSS文件以便缓存,添加Expires头，服务端配置Etag
	请求数量:合并样式和脚本,使用CSS 精灵,初始首屏之外的图片按需加载,静态资源延迟加载
	请求带宽:压缩文件,使用Gzip
	
	代码层面:
		少用全局变量,使用CSS 精灵,缓存DOM查询,避免全局查询,避免使用with,避免在HTML标签中写src属性
	移动端:
		使用CSS3动画,开启硬件加速
		尽量使用touch代替click事件
		避免使用CSS3渐变,阴影效果
		不滥用float
		不滥用网络字体
		
84:一次用户访问HTTP页面的过程
	1:DNS查询
	2:TCP连接
	3:HTTP请求
	4:服务器响应
	5:客户端渲染
	
85:如何快速实现渲染?
	1:服务器必须在200ms以内渲染出响应内容
	2:重定向的次数应该减至最少
	3:首次渲染所需的网络往返次数减至最少
		由于TCP的拥塞窗口机制,首次TCP连接一般只能发送10个包,即大概14KB的数据,所以首页的内容尽量在14K以内
	4:避免在首屏内容中出现外链的阻塞式JavaScript和css
	
86:堆和栈的区别
	1:栈区:由编译器自动编译释放,存放函数的值,局部变量的值等
	2:堆区:一般由程序员分配释放,若程序员不释放,可能程序结束后会被OS回收
	3:堆:堆可以看作一颗数,如堆排序
	3:栈:后进先出
	
87:快速排序的思想
	1:在数据集中寻找一个基准点,
	2:建立两个数组,风别存储左边和右边的数组
	3:利用递归进行排序
	
88:你觉得jQuery或zepto源码有哪些写的好的地方?
	jQuery将所有代码都写在一个闭包中,并且传入window参数,防止污染全局作用域,而且查找window对象更快
	jQuery将一些原型属性和方法封装在jQuery.prototye中,然后又赋给jQuery.fn 写法比较形象
	jQuery大量使用链模式,即返回this,解决代码,提高了代码效率
	有一些数组和对象经常能用到,jQuery将其保存为局部变量,提高了查找速度
	
89:cookie和session的区别
	1:cookie数据存放在用户浏览器上,session存放在服务器中
	2:cookie可被攻击者盗取用来cookie欺骗,考虑到安全,应该使用session
	3:session会在一定时间内保存在服务器中,当访问量增加,比较消耗服务器性能.
	4:一般来说,将登录信息等重要信息存放在session
		其他信息存放在cookie中
		
90:display:none 和 visibility:hidden的区别
	两者都起到隐藏元素的作用
	display:none 通过收拢当前元素实现隐藏,即不给它分配空间
	visibility:hidden 隐藏对应的元素,但是在文档中仍然保存它的布局
	
91:position:absolute 和 float 属性的异同
	相同点:设置了position:absolute 和 float属性的元素,文档都脱离了正常的文档流,并且可以设置其宽高
	不同点:position:absolute 会覆盖原文档流,float不会覆盖原文档流,会占位置
	
92:box-sizing属性用来控制元素的盒模型的解析模式.默认值是content-box
	content-box:标准盒模型, width = contentWidth
	border-box:IE盒模型,width = contentWidth+padding + border
	
93:CSS3选择符有哪些?
	id选择器,class选择其,tag选择器,子选择器(p>li),后代选择器(p li)
	通配符选择器(*),伪类选择器(p:hover),属性选择器
	
94:说说你对语义化的理解
	1:去掉或丢失样式的时候能够让页面呈现出清晰的结构
	2:有助于SEO:和搜索引擎,因为这两者是靠页面结构来确认关键字权重的
	3:方便其他设备解析
	4:便于团队开发和维护
	
95:常见兼容性问题
	1:png24位的图片在IE6浏览器中
	
96:上下margin重合问题
	ie和ff都存在,相邻的两个div的margin-left和margin-right不会重合,
	但是margin-top和margin-bottom却会重合
	解决方法:养成良好的编程习惯,同时使用margin-top或margin-bottom
	
97:null和undefined的区别
	null表示无,转为数值时为0,undefined表示未赋值,转为数值时为NAN
	一般当变量的声明还没有被初始化时,该变量未undefined
	undefined使用场景:
		1:变量被声明了,但没有被赋值时
		2:调用函数时,该提供的变量没有被提供
		3:对象没有赋值的属性
		4:函数没有返回值时,默认返回undefined
	null使用场景
		1:作为函数的参数
		2:作为原型链的终点
	
98:new操作符具体干了什么?
	1:创建一个空对象,并且this指向该对象,同时还继承了该函数的原型
	2:属性和方法被加入到this中
	3:新创建的对象由this引用,并且隐式返回this
	
99:js延迟加载的方式有哪些
	defer和async,动态创建DOM方式,按需求异步载入js
	
100:call()和apply()的区别和作用?
	动态改变某个类的某个方法的运行上下文
	
101:哪些操作会造成内存泄漏?
	setTimeout的第一个参数使用字符串而非函数的话,会引发内存泄漏
	闭包,控制台日志,循环,移除元素而未移除元素上绑定的监听事件
	
102:对前端工程师这个职位是怎么理解的?它的前景会是怎样?
	前端是最贴近用户的程序员,比后端,数据库,产品经理,运营,安全都进
	前端需要实现:
		1:实现界面交互
		2:提升用户体验
		3:有了node.js,前端可以实现服务端的一些事情
	前端是最贴近用户的程序员,前端的编码相对后端来说多了一个对用户友好
	
103:JavaScript对象的几种创建方式
	工厂模式,构造函数模式,原型模式,混合构造函数和原型模式,动态原型模式,
	寄生构造函数模式,稳妥构造函数模式
	
104:JavaScript继承的6种方法
	原型链继承,借用构造函数继承,组合继承,原型式继承,寄生式继承,寄生组合式继承
	
105:GET和POST的区别,何时使用POST?
	GET:一般用于信息获取,使用URL传递参数,对所发送的数量也有限制,一般在2000个字符内
	POST:一般用于修改服务器上的资源,对所发送的数据没有限制
	GET方式需要使用Request.querystring来获得请求字符串的值,
	而PSOT需要使用Request.Form来获取变量的值
	也就是说GET通过地址栏传值,POST通过表单传值
	然而在以下的一些情况下,请使用POST:
		更新服务器上的文件或数据库
		向服务器发送大量数据
		发送包含未知字符的用户输入时,POST比get更稳定
		
106:ajax的缺点和IE下的问题?
	缺点:1:ajax不支持浏览器back按钮,
		2:安全问题,暴露了与服务器交互的细节
		3:对搜索引擎的支持比较弱
		4:破坏了程序的异常机制
		3:不容易调试
	IE缓存问题
		在IE浏览器下,如果请求的方法是GET,并且GET的URL不变,那么这个结果就会被缓存,只要URL改变就不会被缓存.
		常用的方法是在请求URL后面添加随机数
	
107:谈谈你对重构的理解
	网站重构:在不改变网站的原有功能的前提下,简化结构,增加可读性,而在网页前端保持一致的行为.
	对于传统网站的优化:
		1:将table布局该为div+css布局
		2:使网站前端兼容现代浏览器(以及移动端浏览器)
		3:针对SEO的优化
	深层次的网站重构应该考虑的问题
		1:减少代码间的耦合
		2:让代码保持弹性
		3:严格按规范编写代码
		4:设计可扩展的API
		5:代替旧有的框架,语言
		6:增强用户体验
		7:压缩js,css,image等资源
		8:程序的性能优化
		9:采用CDN进行资源加速
		10:对于DOM操作的优化
		11:HTTP服务器的文件缓存
	
108:说说你对Promise的理解
	Promise有4种状态
		pending:初始状态,非fulfilled或rejected
		fulfilled:成功
		rejected:失败
		settled:Promise已被fulfilled或rejected
	Promise的API有:
		then():
		reject():
		catch():
		all():
		race():
		resolve():
		done():置于回调链的尾端,保证任何可能抛出的错误
		finally():不管Promise最后的状态是什么,都会指向该函数
	
109:说说严格模式的限制
	1:变量必须先声明后使用
	2:函数的参数不能有同名属性,否则报错
	3:不能使用with属性
	4:不能对只读属性赋值,否则报错
	5:不能使用前缀0表示八进制数,否则报错
	6:不能删除不可删除的属性,否则报错
	7:不能删除变量delete prop,会报错,只能delete grobal[prop]
	8:eval不会在它的外层作用域引入变量
	9:eval和arguments不能被重新赋值
	10:arguments不会自动反应函数参数的变化
	11:不能使用arguments.callee
	12:不能使用arguments.caller
	13:禁止this指向全局对象
	14:不能使用fn.callee和fn.caller
	15:增加了保留字(比如 protected,static和interface)
	
110:设立"严格模式的目的",主要有以下几个
	消除JavaScript语法的一些不合理,不严谨之处,
	消除代码运行的一些不安全之处
	提高编译器效率,增加运行速度
	为未来新版本的JavaScript做好铺垫
	
111:expires是什么?
	Expires是RFC 2616协议中和网页缓存相关自段.用来控制缓存的失效日期
	
112:attribute和propety的区别是什么?
	attribute是dom元素在文档中作为html标签拥有的属性
	property就是dom元素在js中作为对象拥有的属性
	所以:
	对于html的标准属性而言,attribute和prototype是等价的,是会自动更新的
	但是对于自定义的属性来说,他们是不等价的,不会自动更新
	
113:说说网络分层里七层模型是哪七层
	应用层,表示层,会话层,传输层,网络层,数据链路层,物理层
	每一层的作用如下:
		物理层:通过媒介传输比特,确定机械及电气特效(单位:比特)
		数据链路层:将比特组装成帧和点到点的传输(帧)
		网络层:负责数据包从源节点到目的节点的传递,并负责网际互连(包)
		传输层:提供端到端的可靠报文传输和错误恢复(段)
		会话层:建立,管理和终止会话(会话协议数据单元)
		表示层:对数据进行防疫,加密和压缩(表示协议数据单元)
		应用层:允许防卫OSI环境的手段(应用协议数据单元)
	
114:

各种协议
ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 
TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 
HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 
DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。

说说mongoDB和MySQL的区别

MySQL是传统的关系型数据库，MongoDB则是非关系型数据库

mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。

对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： 
①弱一致性（最终一致），更能保证用户的访问速度： 
②文档结构的存储方式，能够更便捷的获取数据。

讲讲304缓存的原理

服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。

304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。

什么样的前端代码是好的

高复用低耦合，这样文件小，好维护，而且好扩展。
	


